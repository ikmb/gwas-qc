#!/usr/bin/env perl
# -*- mode:perl -*-

# QC Pipeline launch script
#
# 2018, Jan KÃ¤ssens <j.kaessens@ikmb.uni-kiel.de>

use constant OUT_RS => './out-Rs';
use constant OUT_SNPQCI => './out-SNPQCI';
use constant OUT_SAMPLEQC => './out-SampleQC';
use constant OUT_SNPQCII => './out-SNPQCII';

# TODO Check if nextflow is installed and accessible
use constant NXF_BIN => 'nextflow'; # expect it to be in $PATH

# bare minimum of packages, RZ cluster is not exactly flexible
use 5.20.0;
use Getopt::Long;
use Pod::Usage;
use strict;
use warnings;

use autodie qw(:all); # no stable signal or error handling, yet

# Trim leading and trailing whitespace from argument
sub trim {
    my $s = shift;
    $s =~ s/^\s+|\s+$//g;
    return $s;
}

# Strip leading and trailing double quotes from argument
sub strip_quotes {
    my $s = shift;
    $s =~ s/^"|"$//g;
    return $s;
}

# Returns a hash table that is parsed from the given config file name
# Expects config file path as argument
sub parse_config {
    my %c;
    my $f = shift; # file
    open my $conf, "<", $f or die("Failed to open $f: $!");
    while(<$conf>) {
        if (/^(.+)=(.+)$/) {
            my $key = trim($1);
            my $val = strip_quotes(trim($2));
            $c{$key} = $val;
        }
    }
    return %c;
}

# updates the relevant ENV paths via restricted variable substitution
# Expects config hash reference as argument
sub update_env_paths {
    my $c = shift;

    $c->{'BATCH_DIR'} =~ s/\$\{env.BIND_DIR\}/$c->{BIND_DIR}/;
}

# Wait for the user to 
sub pause {
    my $line = "";
    do {
        say "\nType NEXT (in upper-case letters) and press Enter to continue...";
        $line = <STDIN>;    
    } while($line ne "NEXT\n");
}

# Call the Nextflow executable. Currently only used for output filtering.
# Expects list of command slices (as is used in execv or system) as argument
sub call_nextflow {
    my @args = @_;
    my $cmdline = "@args | grep -v 'WARN: The config file defines settings for an unknown process'";
    system($cmdline);
}

# Parse command-line arguments
my $opt_pause = 0;
my $opt_output = "./";
my $opt_help = 0;
GetOptions("pause" => \$opt_pause,
           "help|?" => \$opt_help,
           "output=s" => \$opt_output);
pod2usage(1) if $opt_help;
pod2usage(1) if @ARGV == 0;

$opt_output =~ s!/*$!/!; # Add trailing slash to output path, if not already done

# Do some rudimentary parsing of the Nextflow config and variable substitution
my %config = parse_config($ARGV[0]);
update_env_paths(\%config);

# Feeds all single-batch datasets from the config file into the
# Rs stage, one after another.
sub run_rs {
    say "--------------------------------------------";
    say "Launching stage 1 'Rs': SNP Name Translation";
    say "--------------------------------------------";

    # Collect batches from configuration and launch Rs.nf for each batch
    my @batches = split (/,/, $config{"disease_names"});
    for (@batches) {
        my $batch = $_;
        my %batchconf = parse_config("$config{BATCH_DIR}/$_.config");
        my @cmd = ("nextflow");
        push @cmd, '-c';
        push @cmd, "$config{BATCH_DIR}/$batch.config";
        for my $c (@ARGV) {
            push @cmd, '-c';
            push @cmd, $c;
        }
        push @cmd, 'run';
        push @cmd, 'Rs.nf';
        push @cmd, '--input';
        push @cmd, "$config{BATCH_DIR}/$batch/orig_files/$batchconf{disease_data_set_prefix_orig}";
        push @cmd, '--output';
        push @cmd, $opt_output . OUT_RS;
        push @cmd, '-resume';
        push @cmd, '-with-report';
        push @cmd, $opt_output . OUT_RS . "/Rs-$batch.report.html";

        say "Processing batch $batch...";
        say "Calling @cmd";
        call_nextflow(@cmd);
    }

    say "Stage 1 completed. Output files have been copied to " . OUT_RS;
}

sub run_snpqci {
    say "---------------------------------------------------------------------";
    say "Launching stage 2 'SNPQCI': Batch merge, HWE and missingness analyses";
    say "---------------------------------------------------------------------";

    # Collect batches from configuration and launch Rs.nf for each batch


    my @cmd = ("nextflow");
    for my $c (@ARGV) {
        push @cmd, '-c';
        push @cmd, $c;
    }

    push @cmd, 'run';
    push @cmd, 'SNPQCI.nf';
    push @cmd, '--rs_dir';
    push @cmd, $opt_output . OUT_RS;
    push @cmd, '--output';
    push @cmd, $opt_output . OUT_SNPQCI;
    push @cmd, '-resume';
    push @cmd, '-with-report';
    push @cmd, $opt_output . OUT_SNPQCI . '/SNPQCI-report.html';

    say "Calling @cmd";
    call_nextflow(@cmd);

    say "Stage 2 completed. Output files have been copied to " . OUT_SNPQCI;
}

sub run_sampleqc {
    say "-----------------------------------------------------------------------";
    say "Launching stage 3 'SampleQC': Pruning, HapMap/1kG merging, PCA analyses";
    say "-----------------------------------------------------------------------";

    # Collect batches from configuration and launch Rs.nf for each batch


    my @cmd = ("nextflow");
    for my $c (@ARGV) {
        push @cmd, '-c';
        push @cmd, $c;
    }

    push @cmd, 'run';
    push @cmd, 'SampleQCI.nf';
    push @cmd, '--input';
    push @cmd, $opt_output . OUT_SNPQCI . "/$config{collection_name}_QCI";
    push @cmd, '--output';
    push @cmd, $opt_output . OUT_SAMPLEQC;
    push @cmd, '-resume';
    push @cmd, '-with-report';
    push @cmd, $opt_output . OUT_SAMPLEQC . '/SampleQC-report.html';

    say "Calling @cmd";
    call_nextflow(@cmd);

    say "Stage 3 completed. Output files have been copied to " . OUT_SAMPLEQC;
}

sub run_snpqcii {
    say "--------------------------------------------------------";
    say "Launching stage 4 'SNPQCII': HF-Test, Monomorphics check";
    say "--------------------------------------------------------";

    # Collect batches from configuration and launch Rs.nf for each batch


    my @cmd = ("nextflow");
    for my $c (@ARGV) {
        push @cmd, '-c';
        push @cmd, $c;
    }

    push @cmd, 'run';
    push @cmd, 'SNPQCII.nf';
    push @cmd, '--input';
    push @cmd, $opt_output . OUT_SAMPLEQC . "/$config{collection_name}_SampleQCI_final";
    push @cmd, '--input_wr';
    push @cmd, $opt_output . OUT_SAMPLEQC . "/$config{collection_name}_SampleQCI_final_withoutRelatives";

    push @cmd, '--output';
    push @cmd, $opt_output . OUT_SNPQCII;
    push @cmd, '-resume';
    push @cmd, '-with-report';
    push @cmd, $opt_output . OUT_SNPQCII . '/SNPQCII-report.html';

    say "Calling @cmd";
    call_nextflow(@cmd);

    say "Stage 4 completed. Output files have been copied to " . $opt_output . OUT_SNPQCII;
    say "The final QC'ed dataset can now be found in " . $opt_output . OUT_SNPQCII . "/$config{disease_data_set_prefix_release}.{bed.bim,fam,log,...}";
}

# TODO Should do some error handling here, i.e. catch IPC exceptions. Needs IPC::System::Simple support, though

run_rs;
pause if $opt_pause;
run_snpqci;
pause if $opt_pause;
run_sampleqc;
pause if $opt_pause;
run_snpqcii;

# Documentation starts here
__END__

=head1 NAME

run-qc - Launch the GWAS QC Pipeline

=head1 SYNOPSIS

run-qc [options] <config1> [<config2> [<confign>]]

 Options:
   --pause          stop after each pipeline stage and wait for the user to
                    press <ENTER>
   --help|-?        show his help message
   --output=<dir>   put generated files into the specified dir instead of the
                    current working directory

 Arguments:
   The only non-option arguments run-qc accepts are configuration file names.
   These files will be passed to Nextflow in this order, using the '-c'
   option. If the parameters defined within the config files clash, the
   first parameter definition takes precedence.
 
 Notes:
   This script expects the nextflow executable to be within the $PATH.
   
