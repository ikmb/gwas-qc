#!/usr/bin/env perl

use 5.024;
use sort 'stable';

# Append "." to include path
BEGIN {push @INC, '.'}

use Time::HiRes qw(gettimeofday);
use Report::Generator;
use Report::Rs;
use Report::SNPQCI;
use Report::SampleQC;
use Report::SNPQCII;

use Data::Dumper;

use strict;
use warnings;

my %phase_order = (
    'Rs' => ['plink_flip', 'plink_exclude'],

    'SNPQCI' => ['merge_batches', 'generate_hwe_diagrams', 'exclude_lists_for_failed_hwe', 'exclude_bad_variants', 'draw_definetti_after_QCI'],

    'SampleQC' => ['apply_precalc_remove_list', 'determine_miss_het', 'prune', 'pca_run', 'flashpca2_pruned_1kG','remove_bad_samples', 'draw_histograms', 'prune_related', 'prune_outliers_without_related', 'ibs_merge_and_verify_wr'],

    'SNPQCII' => ['exclude_variants', 'prune', 'flashpca_pruned', 'draw_histograms_pruned']
    );

my %processors = (
    'Rs' => {
        'plink_flip' => \&Report::Rs::plink_flip,
        'plink_exclude' => \&Report::Rs::plink_exclude
    },
    'SNPQCI' => {
        'merge_batches' => \&Report::SNPQCI::merge_batches,
        'generate_hwe_diagrams' => \&Report::SNPQCI::generate_hwe_diagrams,
        'exclude_lists_for_failed_hwe' => \&Report::SNPQCI::exclude_lists_for_failed_hwe,
        'exclude_bad_variants' => \&Report::SNPQCI::exclude_bad_variants,
        'draw_definetti_after_QCI' => \&Report::SNPQCI::draw_definetti_after_QCI
    }
    ,
    'SampleQC' => {
        'apply_precalc_remove_list' => \&Report::SampleQC::apply_precalc_remove_list,
        'determine_miss_het' => \&Report::SampleQC::determine_miss_het,
        'prune' => \&Report::SampleQC::prune,
        'pca_run' => \&Report::SampleQC::hapmap_eigenstrat,
        'flashpca2_pruned_1kG' => \&Report::SampleQC::onekg_flashpca,
        'remove_bad_samples' => \&Report::SampleQC::remove_bad_samples,
        'draw_histograms' => \&Report::SampleQC::draw_histograms,
        'prune_related' => \&Report::SampleQC::prune_related,
        'prune_outliers_without_related' => \&Report::SampleQC::prune_outliers_without_related,
        'ibs_merge_and_verify_wr' => \&Report::SampleQC::ibs_merge_and_verify_wr,
    },
    'SNPQCII' => {
        'exclude_variants' => \&Report::SNPQCII::exclude_variants,
        'prune' => \&Report::SNPQCII::prune,
        'flashpca_pruned' => \&Report::SNPQCII::flashpca_pruned,
        'draw_histograms_pruned' => \&Report::SNPQCII::draw_histograms, 
    }
    
);

sub expand_path {
    my $base = shift;
    my $hash = shift;

    if ($hash =~ m|(..)/(.*)|) {
        my $hash_base = $1;
        my $hash_remainder = $2;
        opendir(my $dh, "$base/$hash_base/") or die($!);
        my @results = grep { /^$hash_remainder.*/ } readdir($dh);
        closedir $dh;

        if (@results > 0) {
            return $base . "/" . $hash_base . "/" . $results[0];
        } else {
            return "/dev/null";
        }
    }
}

sub cmp_phase {
    my $a_index = -1;
    my $b_index = -1;

    for(my $i = 0; $i < @{$phase_order{$::a->[4]}}; $i++) {
        $a_index = $i if $phase_order{$::a->[4]}->[$i] eq $::a->[0];
        $b_index = $i if $phase_order{$::b->[4]}->[$i] eq $::b->[0];
    }

    return $a_index <=> $b_index;
}

if (@ARGV != 4) {
    print STDERR "Syntax: $0 <pipeline> <tag> <workdir> <target>\n";
    exit 1;
}

my $arg_pipeline = shift @ARGV;
my $arg_tag = shift @ARGV;
my $arg_workdir = shift @ARGV;
my $arg_target = shift @ARGV;

my @execution_phases;

# Parse trace
open (my $trace, '<', 'trace.txt') or die($!);
open (my $tex, '>', $arg_target) or die($!);

<$trace>;
while(<$trace>) {
    chomp;
    my ($process, $procname, $tag, $workdir) = split /;/;
    if (exists $processors{$arg_pipeline}{$process}) {
        push @execution_phases, [$process, $procname, $tag, $workdir, $arg_pipeline];
    }
}
close $trace;

my @ordered_execution_phases = sort cmp_phase @execution_phases;

print "Unordered: " . Dumper(@execution_phases);
print "Ordered: " . Dumper(@ordered_execution_phases);

for my $phaseref (@ordered_execution_phases) {

    my ($process, $procname, $tag, $workdir, ) = @{$phaseref};

    if (exists $processors{$arg_pipeline}{$process}) {
        my $expanded = expand_path($arg_workdir, $workdir);

        print 'Processing ' . $arg_pipeline . '::' . $process . "...\n";

        print $tex $processors{$arg_pipeline}{$process}->($expanded, $tag);
    }
}

close $tex;


